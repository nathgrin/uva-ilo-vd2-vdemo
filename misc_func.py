
import numpy as np

import matplotlib.pyplot as plt

plt.rc('font',family='STIXGeneral',size=12) # STIX looks like latex
plt.rc('mathtext',fontset='stix')
# plt.rc('figure', figsize=(1.41421356237*6.,6.) )
# plt.rc('figure.subplot', right=0.96464466094,top=0.95 )
plt.rc('lines', linewidth=1.8,marker='None',markersize=8 )
plt.rc('axes', linewidth=1.5,labelsize=12,prop_cycle=plt.cycler(color=('k','r','c','darkorange','steelblue','hotpink','gold','b','maroon','darkgreen')) )
plt.rc(('xtick.major','ytick.major'), size=5.2,width=1.5)
plt.rc(('xtick.minor','ytick.minor'), size=3.2,width=1.5,visible=True)
plt.rc(('xtick','ytick'), labelsize=8)#, direction='in' )
# plt.rc(('xtick'), top=True,bottom=True ) # For some stupid reason you have to do these separately
# plt.rc(('ytick'), left=True,right=True )
# plt.rc('legend',numpoints=1,scatterpoints=1,labelspacing=0.2,fontsize=18,fancybox=True,handlelength=1.5,handletextpad=0.5)
# plt.rc('savefig', dpi=150,format='pdf',bbox='tight' )
# plt.rc('errorbar',capsize=3.)
# plt.rc('text',usetex=True)

# plt.rc('image',cmap='gist_rainbow')

def merge_pdfs(filenames,outfilename,delete=False):
    ''' () -> float
    '''
    from PyPDF2 import PdfFileMerger, PdfFileReader

    merger = PdfFileMerger()
    for filename in filenames:
        with open(filename,'rb') as fd:
            merger.append(PdfFileReader(fd))

    while True:
        try:
            merger.write(outfilename)
            break
        except IOError as msg:
            print("Could not write file:",msg)
            input( "Fix it and press Enter to try again" )

    if delete:
        from os import remove
        for filename in filenames: remove(filename)

    return





	### --- Manipulate files --- ###
class manipulate_files(object):
	def __init__(self,filestring,fdir=""):
		''' (str,str="")
		By Nathan Grin
		
		Use for manipulating files.
		filename = fdir + filestring
		Functions:
		- read_alllines()
		- write_appline(, writeline)
		'''
		self.filename = fdir+filestring
	
	# Read file and put content into nested list filecontent
	def read_alllines(self,skipto=0):
		''' (int=0) -> list
		Read file 'self.filename' from line 'skipto' on and put content into nested list of strings 'filecontent'
		'''
		my_file = open(self.filename,'r')
		
		raw_filecontent = my_file.readlines()
		filecontent = list(range(len(raw_filecontent)))
		
		for i in range(skipto,len(raw_filecontent)):
			filecontent[i] = raw_filecontent[i].strip().split()
		
		my_file.close()		# Close file
		return filecontent
	
	# Read columns
	def read_cols(self,cols=[0,1]):
		''' (int=[0,1]) -> list
		Read from file, columns cols (default first 2)
		'''
		data,datalist = self.read_alllines(),[[] for i in range(len(cols))]
		for i in cols:
			for row in data: 
				if len(row)>=i: datalist[cols.index(i)].append(row[i])
		return datalist
	
	# Read columns from DAT file of calculated lines generated by FASTWINDs inicalc
	def read_FWdata(self):
		''' () -> list
		Read from file, columns cols (default first 2)
		from DAT file of calculated lines generated by FASTWINDs inicalc
		also read VFTS spectra data
		'''
		data,datalist = self.read_alllines(),[[],[]]
		
		if len(data[2]) == 2: # Convolved data contains 2 cols
			cols=[0,1]
			ran = 1
			rowtotal = len(data)-1 # and is prepended by line #$$$ stating length
		elif len(data[2]) == 6: # FASTWIND data contains 6 cols
			cols=[2,4]
			ran = 0
			rowtotal = 161
		elif len(data[2]) == 3: # VFTS data contains 3 cols
			cols=[0,1]
			ran = 0
			rowtotal = len(data)
		
		from numpy import array
		data = data[ran:]
		data = array(data,dtype='float64').transpose()
		datalist = [ data[cols[0]].tolist(),data[cols[1]].tolist() ]
		return datalist
		
		## OLD sequence
		# start from row ran, run for rowtotal rows
		# FASTWIND + convolved data have 161 rows, spectra depends, resampled data depends
		for i in cols:
			for j in range(ran,rowtotal+ran):
				if len(data[j])>=i: datalist[cols.index(i)].append(float(data[j][i]))
		return datalist
		
	
	
	
	# Append one line ('writeline') to file
	def write_appline(self, writeline):
		''' (str) -> NULL
		Append one line 'writeline' to file 'filename'
		'''
		my_file = open(self.filename,'a')
		my_file.write(writeline)
		my_file.write('\n')
		my_file.close()		# Close file
		#return
	
	def clearfile(self):
		''' (NULL) -> NULL
		Clear file contents
		'''
		open(self.filename,'w').close()
	
		#return
	
	def read_csv_all(self):
		''' (NULL) -> array
		Read file contents
		'''
		from numpy import array
		from csv import reader
		read,datalist = reader(open(self.filename,'rb')),[]
		for data in read: datalist.append([i for i in data])
		datalist = datalist
		return datalist
	
	def read_datafile(self):
		''' (NULL) -> array
		Read file contents,
		return dictionary with keys from first row, per key the column as list
		'''
		datadict = {}
		data = self.read_alllines()
		header = data[0][1:] # Skip the hashtag, which was first element of the header
		data = data[1:]
		for i in range(len(header)):
			datadict[header[i]] = [ data[j][i] for j in range(len(data)) ]
		return datadict
		
	def read_datafile_float(self):
		''' (NULL) -> array
		Read file contents,
		return dictionary with keys from first row, per key the column as list
		'''
		datadict = {}
		data = self.read_alllines()
		header = data[0][1:] # Skip the hashtag, which was first element of the header
		data = data[1:]
		for i in range(len(header)):
			datadict[header[i]] = [ float(data[j][i]) for j in range(len(data)) ]
		return datadict
		
		
	def read_datafile_rows(self):
		''' (NULL) -> array
		Read file contents,
		return dictionary, with keys from first column,
		with as values dictionary with keys from first row
		'''
		datadict = {}
		data = self.read_alllines()
		header = data[0][1:] # Skip the hashtag, which was first element of the header
		#~ print header
		data = data[1:]
		for i in range(len(data)):
			datadict[data[i][0]] = {}
			for j in range(len(header)-1):
				datadict[data[i][0]][header[j+1]] = data[i][j+1]
		return datadict
		
		
	def read_datafile_rows_float(self):
		''' (NULL) -> array
		Read file contents,
		return dictionary, with keys from first column,
		with as values dictionary with keys from first row
		'''
		datadict = {}
		data = self.read_alllines()
		header = data[0][1:] # Skip the hashtag, which was first element of the header
		#~ print header
		data = data[1:]
		for i in range(len(data)):
			datadict[data[i][0]] = {}
			#~ print data[i]
			for j in range(len(header)-1):
				datadict[data[i][0]][header[j+1]] = float(data[i][j+1])
		return datadict
		
	def load_file_bin(self,nhead=1,delimiter=None,confirm_use_binary=False,verbose=False,nonverbose=False,delete=False):
		""" Will load ascii, make binary file if not exists
		    or load binary data file, if it exists
		    
		    if confirm_use_binary: Ask if you want to use the binary else refresh it
		    nhead: # Should one skip the first few lines, e.g. because they contain a header?
		    note: better not save header in binary file, because of load() function
		    
		credit to Selma
		"""
		from os.path import isfile
		from numpy import genfromtxt,save,load
		from os.path import getmtime
		
		
		# Insert filename of your asscii file here
		myfile = self.filename
		
		# The new binary file will be stored with the same name but with the extention.npy iso .any
		mybinfile = myfile.rsplit('.',1)[0]+".npy"
		
		binary_exists = isfile(mybinfile) # Check if .npy exists already...
		
		if binary_exists:
			if getmtime(myfile) > getmtime(mybinfile): # Check if binary is outdated
				if not nonverbose:
					print( " >>> Warning!" )
					print( "     Verbose or not, I will warn you that:" )
					print( "     %s is newer than\n     %s"%(myfile,mybinfile) )
					print( "     This probably means you have updated the ASCII and" )
					print( "     I propose you delete the binary such that I will refresh it" )
					
			
			if confirm_use_binary:
				print( " Refresh binary file %s? "%mybinfile )
				answer = input(""" Type 'yes' or 'y' to refresh, anything else to use: """ )
				if answer == 'yes' or answer == 'y': binary_exists = False
			elif delete:
				print( " >>> Uh Oh!!! I am refreshing the binary file, but did not bother to ask you !! " )
				binary_exists = False
			
			
		if not binary_exists: 
			
			if verbose:
				print( "... Binary file does not yet exist" )
				print( "...    reading ascci file ", myfile )
				print( "...    and storing it for you in binary format" )
				print( "...    patience please, next time will be way faster " )
				print( "...    I promise" )
			
			# If binary does not exist, read the original ascii file:
			if (not isfile(myfile)):  raise IOError( "File %s does not exist "%myfile )
		
			# Read after skipping "nhead" lines, store in a numpy.array
			data = genfromtxt(myfile, delimiter=delimiter,skip_header=nhead)
		
			# Save the numpy array to file in binary format
			save(mybinfile, data)
		
		else:
			
			if verbose: print( "... Great. Binary file exists, reading data directly from: ", mybinfile )
			
			# If binary file exists load it directly.
			data = load(mybinfile)
		
		# You can now access all data with this array
		return data

